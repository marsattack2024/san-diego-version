# Authentication Middleware Streamlining Plan

## Current Architecture Analysis

Our current authentication implementation suffers from multiple overlapping systems:

1. **Redundant Authentication Mechanisms**:
   - Middleware auth (`middleware.ts` + `updateSession`)
   - Context-based auth (`AuthProvider`)
   - Store-based auth (`auth-store.ts`)
   - Service-level auth (e.g., `history-service.ts` circuit breaker)

2. **Root Problems**:
   - Inconsistent auth verification creates race conditions
   - Custom error handling instead of leveraging Supabase's built-in security
   - Redundant security layers with RLS and custom logic both present
   - Lack of proper loading states during authentication checks

3. **Auth Failures**:
   - "Auth session missing!" errors when components render before auth is ready
   - Empty sidebar when auth state isn't properly synchronized
   - Redundant database queries for admin status checking

## Implementation Plan Using @supabase/ssr

### Phase 1: Standardize Client Utilities (Week 1)

**Files to Create/Modify**:

1. `utils/supabase/client.ts` - Browser client for client components
```typescript
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}
```

2. `utils/supabase/server.ts` - Server client for server components
```typescript
import { createServerComponentClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createClient() {
  const cookieStore = cookies();
  
  return createServerComponentClient({
    cookies: () => cookieStore
  });
}
```

3. `utils/supabase/route-client.ts` - Client for route handlers
```typescript
import { cookies } from 'next/headers';
import { createRouteHandlerClient } from '@supabase/ssr';

export async function createClient() {
  const cookieStore = cookies();
  
  return createRouteHandlerClient({
    cookies: () => cookieStore
  });
}
```

4. `lib/auth/with-auth.ts` - Route handler auth wrapper
```typescript
import { createClient } from '@/utils/supabase/route-client';
import { NextResponse } from 'next/server';
import type { User } from '@supabase/supabase-js';

type AuthHandler = (user: User, req: Request) => Promise<Response>;

export async function withAuth(handler: AuthHandler): Promise<(req: Request) => Promise<Response>> {
  return async (req: Request) => {
    try {
      const supabase = await createClient();
      const { data: { user }, error } = await supabase.auth.getUser();
      
      if (error || !user) {
        return NextResponse.json(
          { error: 'Authentication required' },
          { status: 401 }
        );
      }
      
      return await handler(user, req);
    } catch (error) {
      console.error('Auth error:', error);
      return NextResponse.json(
        { error: 'Server error' },
        { status: 500 }
      );
    }
  };
}
```

**Testing Strategy**:
- Unit test each client utility
- Verify they return appropriate clients
- Test the withAuth wrapper with mocked auth responses

### Phase 2: Implement Core Auth Middleware (Week 1-2)

**Files to Modify**:

1. `middleware.ts` - Streamline auth middleware
```typescript
import { NextResponse, type NextRequest } from 'next/server';
import { createMiddlewareClient } from '@supabase/ssr';

export async function middleware(request: NextRequest) {
  // Create response and middleware client
  const response = NextResponse.next();
  const supabase = createMiddlewareClient({
    req: request,
    res: response,
  });

  // This updates session cookies AND validates the session with Supabase server
  const { data: { user } } = await supabase.auth.getUser();
  
  // Redirect to login if no valid user and accessing protected route
  if (!user) {
    const redirectUrl = new URL('/login', request.url);
    redirectUrl.searchParams.set('redirectTo', request.nextUrl.pathname);
    return NextResponse.redirect(redirectUrl);
  }
  
  // Continue with refreshed session
  return response;
}

// Configure middleware to run ONLY on routes that require authentication
export const config = {
  matcher: [
    // Include paths requiring auth
    '/chat/:path*',
    '/admin/:path*',
    '/api/chat/:path*',
    '/api/history/:path*',
  ],
};
```

**Testing Strategy**:
- Test middleware with various path scenarios
- Verify redirect behavior for unauthenticated requests
- Verify authentication cookies are correctly refreshed
- Test security by attempting to access protected routes with invalid/expired tokens

### Phase 3: Refactor Auth Provider and Store (Week 2)

**Files to Modify**:

1. `utils/supabase/auth-provider.tsx` - Simplify auth provider
```typescript
'use client';

import React, { createContext, useContext, useState, useEffect } from 'react';
import { createClient } from '@/utils/supabase/client';
import { useAuthStore } from '@/stores/auth-store';
import { Loader2 } from 'lucide-react';

// Simplified context with just loading state and client
const AuthContext = createContext({
  isLoading: true,
  supabase: null as ReturnType<typeof createClient> | null,
});

export const useAuth = () => useContext(AuthContext);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [isLoading, setIsLoading] = useState(true);
  const [supabase] = useState(() => createClient());
  const { setUser, clearUser, loadUserProfile } = useAuthStore();

  // Setup auth state change listener
  useEffect(() => {
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      async (event, session) => {
        if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED') {
          setUser(session?.user || null);
          if (session?.user) {
            await loadUserProfile();
          }
        } else if (event === 'SIGNED_OUT') {
          clearUser();
        }
        
        // Always update loading state
        setIsLoading(false);
      }
    );

    // Initial auth check
    supabase.auth.getUser().then(({ data: { user } }) => {
      setUser(user);
      if (user) {
        loadUserProfile();
      }
      setIsLoading(false);
    });

    return () => {
      subscription.unsubscribe();
    };
  }, [supabase, setUser, clearUser, loadUserProfile]);

  // Show loading state while initial auth check completes
  if (isLoading) {
    return (
      <div className="flex h-screen w-screen items-center justify-center">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
        <span className="ml-2 text-lg">Loading authentication...</span>
      </div>
    );
  }

  return (
    <AuthContext.Provider value={{ isLoading, supabase }}>
      {children}
    </AuthContext.Provider>
  );
}
```

2. `stores/auth-store.ts` - Simplify auth store
```typescript
// Simplified version focused on derived state
// Remove periodic auth checking, rely on onAuthStateChange
```

**Testing Strategy**:
- Test authentication state synchronization
- Verify loading states are properly displayed
- Test auth state change events update store correctly

### Phase 4: Refactor History Service (Week 2-3)

**Files to Modify**:

1. `lib/api/history-service.ts` - Remove circuit breaker, use RLS, implement dependency injection
```typescript
import { clientCache } from '@/lib/cache/client-cache';
import { edgeLogger } from '@/lib/logger/edge-logger';
import { LOG_CATEGORIES } from '@/lib/logger/constants';
import { Chat } from '@/lib/db/schema';
import type { SupabaseClient } from '@supabase/supabase-js';

// Simplified history service that relies on RLS with dependency injection
export const historyService = {
  /**
   * Fetch chat history for the current user
   * @param supabase - The Supabase client instance appropriate for the calling context
   * @param forceRefresh - Whether to bypass cache and force refresh
   */
  async fetchHistory(supabase: SupabaseClient, forceRefresh = false): Promise<Chat[]> {
    const cacheKey = 'chat_history';
    const operationId = `history_${Date.now().toString(36)}`;
    
    // Return cached data if available and not forced refresh
    if (!forceRefresh) {
      try {
        const cachedData = clientCache.get(cacheKey) as Chat[] | undefined;
        if (cachedData && Array.isArray(cachedData)) {
          return cachedData;
        }
      } catch (e) {
        edgeLogger.debug('Cache miss or error', { category: LOG_CATEGORIES.SYSTEM });
      }
    }
    
    try {
      edgeLogger.debug('Fetching chat history', { 
        category: LOG_CATEGORIES.CHAT,
        operationId 
      });
      
      // Use the provided Supabase client instance
      // Fetch sessions - will return empty array if not authenticated due to RLS
      const { data: sessions, error } = await supabase
        .from('sd_chat_sessions')
        .select('id, title, created_at, updated_at, agent_id, user_id, deep_search_enabled')
        .order('updated_at', { ascending: false });
        
      if (error) {
        edgeLogger.error('Error fetching chat sessions', {
          category: LOG_CATEGORIES.CHAT,
          operationId,
          error: error.message
        });
        return []; // Return empty array on error
      }
      
      // Map to Chat objects
      const chats: Chat[] = (sessions || []).map(session => ({
        id: session.id,
        title: session.title || 'Untitled Chat',
        createdAt: session.created_at,
        updatedAt: session.updated_at,
        userId: session.user_id,
        messages: [],
        agentId: session.agent_id || 'default',
        deepSearchEnabled: session.deep_search_enabled || false
      }));
      
      // Cache results
      clientCache.set(cacheKey, chats, 30 * 60 * 1000); // 30 minutes
      
      return chats;
    } catch (error) {
      edgeLogger.error('Error in fetchHistory', {
        category: LOG_CATEGORIES.CHAT,
        operationId,
        error: error instanceof Error ? error.message : String(error)
      });
      
      // Return empty array rather than throwing
      return [];
    }
  },
  
  // Other methods refactored with dependency injection similarly...
};
```

2. Example usage in a client component:
```typescript
'use client';

import { useEffect, useState } from 'react';
import { createClient } from '@/utils/supabase/client';
import { historyService } from '@/lib/api/history-service';

export function SidebarHistory() {
  const [history, setHistory] = useState([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    const fetchData = async () => {
      const supabase = createClient(); // Client-side client
      const data = await historyService.fetchHistory(supabase);
      setHistory(data);
      setLoading(false);
    };
    
    fetchData();
  }, []);
  
  // Component JSX
}
```

3. Example usage in a server component:
```typescript
import { createClient } from '@/utils/supabase/server';
import { historyService } from '@/lib/api/history-service';

export default async function ServerHistoryComponent() {
  const supabase = await createClient(); // Server-side client
  const history = await historyService.fetchHistory(supabase);
  
  return (
    <div>
      {/* Render history */}
    </div>
  );
}
```

4. Verify RLS policies in Supabase:
```sql
-- Ensure proper RLS policies exist for chat tables
CREATE POLICY "Users can view their own chats" 
ON sd_chat_sessions
FOR SELECT
USING (auth.uid() = user_id);

-- Similar policies for other operations (INSERT, UPDATE, DELETE)
```

**Testing Strategy**:
- Test history fetching with authenticated and unauthenticated users
- Test with both server-side and client-side Supabase clients
- Verify empty results (not errors) when not authenticated
- Test caching behavior
- Verify RLS policies are correctly applying data filtering
- Unit test the service with mock Supabase clients

### Phase 5: Update Components with Auth Awareness (Week 3)

**Files to Modify**:

1. `components/sidebar-history.tsx` - Add proper loading states
```typescript
// Add auth-aware loading and error states
```

2. `components/virtualized-chat.tsx` - Add auth checking

3. Other components that interact with auth state or services

**Testing Strategy**:
- Test components with various auth states
- Verify loading indicators display correctly
- Confirm error states are handled gracefully

### Phase 6: Implement Admin Status Handling (Week 3-4)

**Option A: JWT Custom Claims** (recommended):

1. Create Supabase DB function for admin claims:
```sql
create or replace function public.set_admin_claim()
returns trigger as $$
begin
  if new.is_admin = true then
    update auth.users set raw_app_meta_data = 
      coalesce(raw_app_meta_data, '{}'::jsonb) || 
      jsonb_build_object('is_admin', true)
    where id = new.user_id;
  else
    update auth.users set raw_app_meta_data = 
      coalesce(raw_app_meta_data, '{}'::jsonb) - 'is_admin'
    where id = new.user_id;
  end if;
  return new;
end;
$$ language plpgsql security definer;

-- Create trigger
create or replace trigger on_admin_status_update
  after insert or update of is_admin on public.sd_user_profiles
  for each row execute procedure public.set_admin_claim();
```

2. Update admin-related components to check user claims directly

**Option B: Server-Side Admin Check** (alternative):

1. `app/admin/layout.tsx` - Add comprehensive admin check
```typescript
// Server component with admin verification
```

**Testing Strategy**:
- Test admin routes with admin and non-admin users
- Verify proper redirects for unauthorized access
- Test admin claim updates propagate correctly
- Specific admin trigger tests:
  1. Create a non-admin user and verify no admin claim exists
  2. Update the user's profile to make them an admin
  3. Verify the claim was added to `auth.users.raw_app_meta_data`
  4. Verify the JWT token contains the claim after refresh
  5. Test that admin routes recognize the user as an admin
  6. Remove admin status and verify the claim is removed

### Phase 7: Standardize API Routes (Week 4)

1. Update all API routes to use the `withAuth` wrapper
2. Ensure consistent error format across all endpoints
3. Update route handlers to leverage RLS properly

**Testing Strategy**:
- Test API endpoints with authenticated and unauthenticated requests
- Verify proper status codes are returned
- Confirm error formats are consistent

## Legacy Files to Delete After Implementation

Once the new authentication system is fully implemented and tested, these files can be removed or significantly simplified:

1. **Files to Delete**:
   - `utils/supabase/middleware.ts` (replaced by simplified version)
   - Any custom circuit breaker implementation files
   - Custom auth error handling utilities

2. **Files to Simplify**:
   - `lib/api/history-service.ts` (remove circuit breaker and auth checks)
   - `stores/auth-store.ts` (remove redundant auth refresh logic)
   - `utils/supabase/auth-provider.tsx` (simplify to just maintain auth state)

## Testing Strategy

### Unit Tests:
- Test each utility function (client creators, auth wrappers)
- Test middleware with various route scenarios

### Integration Tests:
- Test authentication flow (login, logout, session persistence)
- Test protected routes and redirects
- Test API endpoints with various auth states

### End-to-End Tests:
- Complete user journey tests (login → access protected content → logout)
- Admin functionality tests
- Authentication error recovery tests

## Benefits of This Approach

1. **Simplification**: Removes redundant authentication checks
2. **Consistency**: All components use the same authentication mechanism
3. **Security**: Relies on Supabase RLS for data protection
4. **Performance**: Eliminates unnecessary API calls and DB queries
5. **Maintainability**: Follows standard Supabase patterns
6. **User Experience**: Proper loading states and error handling

## Monitoring & Validation

After implementation, monitor:
1. Authentication-related errors in logs
2. API response times for authenticated endpoints
3. User feedback on authentication experience
4. Any unexpected authentication failures
