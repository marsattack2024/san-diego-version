# Plan: Implement AI Workflow Orchestrator using Vercel AI SDK

**Goal:** Create a flexible, multi-step AI workflow orchestrator in `lib/ai/orchestrator.ts` based on the provided plan ("GROX idea"), using the Vercel AI SDK (`ai` package) for dynamic routing and agent management.

**Instructions:**

1.  **Install Dependencies:**
    * Ensure the necessary packages are installed in your project.
    * Run the following command in your terminal:
        ```bash
        npm install ai @ai-sdk/openai zod
        # or pnpm install ai @ai-sdk/openai zod
        # or yarn add ai @ai-sdk/openai zod
        ```

2.  **Create Orchestrator File (`lib/ai/orchestrator.ts`):**
    * Create the directory `lib/ai` if it doesn't exist.
    * Create a new file named `orchestrator.ts` inside `lib/ai`.
    * Populate `lib/ai/orchestrator.ts` with the following TypeScript code:

        ```typescript
        import { openai } from '@ai-sdk/openai';
        import { generateObject, generateText, LanguageModel } from 'ai'; // Added LanguageModel type
        import { z } from 'zod';

        // Define Agent Configuration Structure
        interface AgentConfig {
          model: LanguageModel; // Use LanguageModel type from 'ai'
          system: string;
        }

        // Define agent types and their configs
        const AGENTS: Record<string, AgentConfig> = {
          copywriter: {
            model: openai('gpt-4o'), // Ensure you have configured OpenAI provider
            system: 'You are a copywriting expert focusing on emotional appeal, benefits, and clarity.',
          },
          googleAds: {
            model: openai('gpt-4o'),
            system: 'You are a Google Ads specialist creating targeted campaigns with strong CTAs.',
          },
          validator: {
            model: openai('gpt-4o'),
            system: 'You are a quality checker evaluating marketing content for consistency and effectiveness.',
          },
          // Add other agents like 'featureExtractor', 'strategicPlanner' etc. as needed
        };

        // Define available agent keys as an enum for schema validation
        const agentKeys = Object.keys(AGENTS) as [keyof typeof AGENTS, ...(keyof typeof AGENTS)[]]; // Ensures at least one key
        const agentEnum = z.enum(agentKeys);

        // Schema for a single step in the workflow plan
        const workflowStepSchema = z.object({
          agent: agentEnum,
          task: z.string().describe("Specific instructions for the agent for this step."),
          dependsOn: z.array(z.number()).optional().describe("Indices of steps (0-based) that must be completed before this step can start."),
        });

        // Schema for the overall workflow plan
        const workflowPlanSchema = z.object({
          steps: z.array(workflowStepSchema).describe("Sequence of steps to execute."),
          maxIterations: z.number().default(5).describe("Maximum iterations to prevent infinite loops during re-planning."),
        });

        // Schema for the output expected from each agent worker
        const agentOutputSchema = z.object({
          result: z.string().describe("The main output content generated by the agent."),
          metadata: z.object({
            qualityScore: z.number().min(1).max(10).describe("Agent's self-assessment of output quality (1-10)."),
            needsRevision: z.boolean().describe("Flag indicating if the agent believes its output needs review or revision."),
            issues: z.array(z.string()).optional().describe("Specific issues identified if revision is needed."),
          }).describe("Metadata about the agent's execution and output quality."),
        });

        // Type for the context object storing results
        type WorkflowContext = Record<number, z.infer<typeof agentOutputSchema>>;

        /**
         * Runs the AI workflow orchestrator.
         * @param request The initial user request or goal.
         * @returns An object containing the final compiled result and the detailed steps taken.
         */
        export async function runOrchestrator(request: string) {
          // Ensure OPENAI_API_KEY is configured via environment variables for @ai-sdk/openai
          const orchestratorModel = openai('gpt-4o'); // Or potentially a smaller/faster model for planning like 'gpt-4o-mini'

          console.log("Orchestrator: Generating initial workflow plan...");
          // Step 1: Generate the initial workflow plan
          const { object: plan, usage: planUsage } = await generateObject({
            model: orchestratorModel,
            schema: workflowPlanSchema,
            system: `You are a marketing workflow manager. Plan a sequence of agent tasks based on the request. Define clear tasks and dependencies between steps. Available agents: ${agentKeys.join(', ')}.`,
            prompt: `Analyze this request and create a detailed workflow plan: "${request}"`,
          });
          console.log("Orchestrator: Initial plan generated:", JSON.stringify(plan, null, 2));
          console.log("Orchestrator: Planning usage:", planUsage);


          // Context to store outputs and state
          let context: WorkflowContext = {};
          let iteration = 0;
          let currentPlan = plan; // Use a mutable variable for the plan

          console.log(`Orchestrator: Starting execution loop (max ${currentPlan.maxIterations} iterations)...`);
          // Step 2: Execute the plan with dynamic routing
          while (iteration < currentPlan.maxIterations) {
            console.log(`Orchestrator: --- Iteration ${iteration + 1} ---`);
            let madeProgress = false; // Track if any step was executed in this iteration
            let allStepsComplete = true; // Assume completion until a step is found incomplete

            for (let i = 0; i < currentPlan.steps.length; i++) {
              const step = currentPlan.steps[i];

              // Check if step already completed
              if (context[i]) {
                console.log(`Orchestrator: Step ${i} (${step.agent}) already completed.`);
                continue;
              }

              allStepsComplete = false; // Found an incomplete step

              // Check dependencies
              const dependenciesMet = !step.dependsOn || step.dependsOn.every(depIndex => context[depIndex]);
              if (!dependenciesMet) {
                console.log(`Orchestrator: Step ${i} (${step.agent}) dependencies not met yet.`);
                continue; // Skip this step for now
              }

              console.log(`Orchestrator: Executing Step ${i}: Agent=${step.agent}, Task=${step.task}`);
              // --- Run the agent ---
              const agentConfig = AGENTS[step.agent];
              if (!agentConfig) {
                 console.error(`Orchestrator: Error - Agent configuration for '${step.agent}' not found.`);
                 // Decide how to handle this - skip, fail, re-plan?
                 continue; // Simple skip for now
              }

              // Prepare context string carefully - potentially summarize or select relevant parts
              const relevantContext = JSON.stringify(context); // Simplistic context passing

              try {
                const { object: output, usage: agentUsage } = await generateObject({
                  model: agentConfig.model,
                  schema: agentOutputSchema,
                  system: agentConfig.system,
                  prompt: `Task: ${step.task}\n\nRelevant previous results:\n${relevantContext}`,
                   // Add temperature, maxTokens etc. if needed per agent
                });
                console.log(`Orchestrator: Step ${i} (${step.agent}) completed. Output metadata:`, output.metadata);
                console.log(`Orchestrator: Agent usage:`, agentUsage);


                context[i] = output; // Store successful output
                madeProgress = true;

                // --- Step 3: Evaluate and potentially adjust plan ---
                if (output.metadata.needsRevision) {
                  console.log(`Orchestrator: Step ${i} (${step.agent}) flagged for revision. Re-planning...`);
                  const { object: revisedPlanData, usage: replanUsage } = await generateObject({
                    model: orchestratorModel, // Use orchestrator model for re-planning
                    schema: workflowPlanSchema,
                    system: 'You are the workflow manager. Adjust the workflow based on agent feedback. You can modify steps, add new steps (e.g., an editing step before validation), or re-order tasks. Explain your reasoning clearly if possible in the plan.',
                    prompt: `Step ${i} (${step.agent}) requires revision based on its output: ${JSON.stringify(output)}\n\nCurrent workflow plan: ${JSON.stringify(currentPlan)}\n\nPlease provide an updated plan to address the issue and achieve the original goal: "${request}"`,
                  });

                  console.log("Orchestrator: Re-planning complete. New plan:", JSON.stringify(revisedPlanData, null, 2));
                  console.log("Orchestrator: Re-planning usage:", replanUsage);


                  currentPlan = revisedPlanData; // Update the plan
                  context = {}; // Reset context as the plan changed significantly (or implement smarter context migration)
                  console.log("Orchestrator: Plan updated due to revision request. Resetting context and restarting iteration loop.");
                  madeProgress = false; // Don't count this as progress for termination check below
                  allStepsComplete = false; // Ensure loop continues with new plan
                  break; // Exit inner loop (steps) to restart the iteration with the new plan
                }
              } catch(error) {
                 console.error(`Orchestrator: Error executing Step ${i} (${step.agent}):`, error);
                 // Implement error handling: retry, mark step as failed, re-plan, etc.
                 // For now, just log and continue, which might stall the workflow
                 allStepsComplete = false; // Ensure workflow doesn't incorrectly terminate
              }
            } // End of for loop (steps)

            // Check for termination conditions
            if (allStepsComplete) {
               console.log("Orchestrator: All planned steps completed.");
               break; // Exit while loop
            }

            if (!madeProgress && !allStepsComplete) {
               console.warn("Orchestrator: No progress made in this iteration, potential deadlock or unmet dependencies. Exiting.");
               break; // Prevent infinite loops if stuck
            }

            iteration++;
            if (iteration >= currentPlan.maxIterations) {
               console.warn("Orchestrator: Max iterations reached. Exiting loop.");
            }

          } // End of while loop (iterations)

          console.log("Orchestrator: Execution loop finished.");
          // Step 4: Compile final result
          // Simple compilation - could be smarter, e.g., use another LLM call
          const finalResult = Object.values(context)
            .map((output, index) => `--- Output from Step ${index} (${currentPlan.steps[index]?.agent || 'N/A'}) ---\n${output.result}`)
            .join('\n\n');

          console.log("Orchestrator: Workflow finished. Returning final result.");
          return {
             finalResult: finalResult,
             stepsTakenDetails: context,
             finalPlan: currentPlan // Return the final plan used
         };
        }

        // Example usage (can be removed or placed elsewhere, e.g., API route)
        /*
        async function runExample() {
          // Ensure OPENAI_API_KEY is set in your environment
          const request = "Create a compelling Google Ads campaign and identify 3 key website copy sections for promoting spring photography mini-sessions targeting young families in Miami. Focus on capturing fleeting moments.";
          try {
            const result = await runOrchestrator(request);
            console.log("\n--- FINAL COMPILED RESULT ---");
            console.log(result.finalResult);
            console.log("\n--- DETAILED STEPS ---");
            console.log(JSON.stringify(result.stepsTakenDetails, null, 2));
            console.log("\n--- FINAL PLAN ---");
            console.log(JSON.stringify(result.finalPlan, null, 2));
          } catch (error) {
            console.error("Error running orchestrator example:", error);
          }
        }

        // runExample(); // Uncomment to run example when executing this file directly
        */
        ```

3.  **Environment Setup (Crucial Note):**
    * Remind the user that this code uses `@ai-sdk/openai`.
    * Instruct them to ensure their OpenAI API key is correctly configured as an environment variable (typically `OPENAI_API_KEY`). They should consult the Vercel AI SDK documentation for setting up providers if needed.

4.  **Integration Point (Placeholder / Next Step):**
    * Advise the user that `runOrchestrator` needs to be called from somewhere.
    * Suggest creating a Next.js API route (e.g., `app/api/orchestrate/route.ts`) as a common integration point.
    * Provide a basic skeleton for this route:

        ```typescript
        // app/api/orchestrate/route.ts (Example)
        import { NextRequest, NextResponse } from 'next/server';
        import { runOrchestrator } from '@/lib/ai/orchestrator'; // Adjust import path as needed

        export async function POST(request: NextRequest) {
          try {
            const body = await request.json();
            const userRequest = body.request;

            if (!userRequest) {
              return NextResponse.json({ error: 'Request query is required' }, { status: 400 });
            }

            // Add validation for userRequest if needed

            const result = await runOrchestrator(userRequest);

            return NextResponse.json(result);

          } catch (error: any) {
            console.error("API Error in /api/orchestrate:", error);
            // Return a generic error message or more specific details based on error type
            return NextResponse.json({ error: 'Failed to run orchestrator', details: error.message || 'Unknown error' }, { status: 500 });
          }
        }
        ```

5.  **Future Enhancements (Add as Comments or Notes):**
    * Suggest adding robust `try...catch` blocks around API calls (`generateObject`) within the loop for better error handling.
    * Recommend exploring more sophisticated context management instead of `JSON.stringify(context)` for larger workflows (e.g., summarizing, selecting relevant history).
    * Suggest refining the evaluation logic (e.g., specific score thresholds, different actions based on feedback).
    * Mention considering persistent state storage (e.g., database) if workflows need to be long-running or resumable.
    * Suggest adding logging/tracing for better debugging.

This plan provides Cursor with specific, actionable instructions to scaffold the orchestrator implementation using the desired Vercel AI SDK approach.