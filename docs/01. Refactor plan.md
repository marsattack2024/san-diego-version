# Chat System Refactoring Plan

## Current Architecture Status

The refactoring of our chat system has been successfully completed, implementing a unified chat engine that serves both our main application and widget experiences. This document outlines the architectural changes made and the current state of the system.

## Implemented Architecture

### Core Chat System
- **API Endpoint**: `app/api/chat/route.ts` - Refactored to use the unified chat engine
- **Frontend**: Components updated to integrate with Vercel AI SDK
- **Features**: Full agent system with AI-based routing, DeepSearch integration, history management
- **Interface**: Rich UI with multiple tools and specialized agent capabilities

### Widget Chat System
- **API Endpoint**: `app/api/widget-chat/route.ts` - Refactored to use the unified chat engine
- **Frontend**: Lightweight components rebuilt with the Vercel AI SDK in `/components/chat-widget`
- **Features**: Optimized RAG with single agent, no authentication, embedding capabilities
- **Interface**: Mobile-friendly widget with improved performance

### Unified Core Components
- **Chat Engine**: `lib/chat-engine/core.ts` - Central processing engine for all chat interactions
- **Message Persistence**: `lib/chat-engine/message-persistence.ts` - Unified history management
- **Cache Service**: `lib/chat-engine/cache-service.ts` - Centralized Redis caching
- **Agent Router**: `lib/chat-engine/agent-router.ts` - AI-powered agent selection using Vercel AI SDK
- **Prompt System**: `lib/chat-engine/prompts/` - Modular prompt management across agent types
- **Tool System**: `lib/chat-engine/tools/` - Unified tools with consistent implementation patterns

## Architectural Improvements

### 1. Unified Chat Engine

Created a modular `ChatEngine` class that:
- Handles the complete request lifecycle following Vercel AI SDK patterns
- Supports different authentication requirements based on context
- Provides consistent error handling and logging
- Integrates with Vercel AI SDK's `streamText` function
- Supports multi-step tool execution with proper callback handling

```typescript
// Chat Engine Configuration Interface
export interface ChatEngineConfig {
    // Basic configuration
    tools?: Record<string, Tool<any, any>>;
    requiresAuth?: boolean;
    corsEnabled?: boolean;

    // AI model configuration
    model?: string;
    systemPrompt?: string;
    maxTokens?: number;
    temperature?: number;

    // Feature flags
    useDeepSearch?: boolean;
    useWebScraper?: boolean;

    // Operational settings
    operationName?: string;
    cacheEnabled?: boolean;
    messageHistoryLimit?: number;
    messagePersistenceDisabled?: boolean;

    // Additional context
    prompts?: any;
    agentType?: string;
    body?: Record<string, any>;
}
```

### 2. AI SDK Integration

Fully integrated with Vercel AI SDK:
- Leveraged `streamText` for streaming responses with proper callback handling
- Used `generateObject` for agent type classification
- Implemented proper tool definitions using the AI SDK's `tool` function
- Added support for multi-step reasoning with `maxSteps` parameter
- Utilized `consumeStream()` to ensure message persistence even when clients disconnect

### 3. Tool Registration System

Built a unified tool registry that:
- Defines tools in a single location following AI SDK patterns
- Allows selective tool inclusion based on agent capabilities and user preferences
- Maintains consistent error handling and logging patterns
- Supports runtime validation of tool parameters and execution conditions

```typescript
// Tool creation follows Vercel AI SDK patterns
export const knowledgeBaseTool = tool({
  description: 'Search the knowledge base for relevant information',
  parameters: knowledgeBaseSchema,
  execute: async ({ query }, runOptions) => {
    // Implementation with proper logging and error handling
  }
});

// Tool registry for conditional tool inclusion
export function createToolSet(options: {
  useKnowledgeBase?: boolean;
  useWebScraper?: boolean;
  useDeepSearch?: boolean;
}): Record<string, Tool<any, any>> {
  // Include tools conditionally based on configuration
}
```

### 4. AI-Powered Agent Routing

Implemented an agent routing system following Vercel AI SDK patterns:
- Used `generateObject` with a Zod schema to analyze message content
- Created direct mapping from agent types to configurations
- Added fallback mechanisms for agent selection failures
- Implemented specialized prompts for each agent type
- Ensured tools are conditionally included based on agent capabilities

```typescript
// Agent routing using Vercel AI SDK generateObject
export async function detectAgentType(message: string, currentAgentType: AgentType = 'default'): Promise<{
  agentType: AgentType;
  config: AgentConfig;
}> {
  try {
    const routingResult = await generateObject({
      model: openai('gpt-4o-mini'),
      schema: agentRoutingSchema,
      prompt: `Analyze this user message and determine which specialized agent should handle it...`,
      temperature: 0.1
    });
    
    return {
      agentType: routingResult.object.agentType as AgentType,
      config: getAgentConfig(routingResult.object.agentType as AgentType)
    };
  } catch (error) {
    // Fallback logic
  }
}
```

### 5. Modular Prompt System

Created a structured prompt system:
- Organized prompts in separate files for maintainability
- Implemented builder functions for prompt composition
- Added specialized prompts for different agent types
- Enhanced prompts with detailed tool usage instructions
- Added citation requirements for DeepSearch results

```typescript
// Prompt system structure
lib/chat-engine/prompts/
  index.ts                # Exports builder functions and types
  base-prompt.ts          # Base prompt shared by all agents
  copywriting-prompts.ts  # Copywriting agent specialized prompt
  google-ads-prompts.ts   # Google Ads agent specialized prompt
  facebook-ads-prompts.ts # Facebook Ads agent specialized prompt
  quiz-prompts.ts         # Quiz agent specialized prompt
  widget-prompt.ts        # Widget prompt for embedded experiences
```

### 6. Centralized Caching

Created a unified caching service that:
- Provides consistent key management with proper namespacing
- Standardizes serialization/deserialization
- Implements specialized methods for different data types
- Handles errors gracefully with detailed logging
- Follows Redis best practices for performance

```typescript
// Cache service methods for different data types
export interface ChatEngineCacheService {
  getSession(userId: string, sessionId: string): Promise<SessionData | null>;
  setSession(userId: string, sessionId: string, data: SessionData): Promise<void>;
  
  getEmbedding(namespace: string, key: string): Promise<number[] | null>;
  setEmbedding(namespace: string, key: string, embedding: number[]): Promise<void>;
  
  getDeepSearch(namespace: string, key: string): Promise<SearchResult | null>;
  setDeepSearch(namespace: string, key: string, result: SearchResult): Promise<void>;
  
  // Other specialized methods...
}
```

### 7. Frontend Component Updates

Updated frontend components to work with Vercel AI SDK:
- Created custom `useAppChat` hook to wrap Vercel AI SDK's `useChat`
- Rebuilt the chat widget using Vercel AI SDK patterns
- Added support for tool call visualization in the UI
- Implemented streaming message displays
- Enhanced error handling and retry mechanisms

## Current Implementation Details

### Route Handler Implementation

```typescript
// app/api/chat/route.ts
export async function POST(req: Request) {
  // Extract body and process messages
  
  // Detect agent type using AI-powered classification
  const { agentType, config: agentConfig } = await detectAgentType(
    lastUserMessage.content as string,
    requestedAgentId as any
  );
  
  // Configure Deep Search conditionally
  const shouldUseDeepSearch = agentConfig.toolOptions.useDeepSearch && deepSearchEnabled;
  
  // Create tools with conditional inclusion
  const tools = createToolSet({
    useKnowledgeBase: agentConfig.toolOptions.useKnowledgeBase,
    useWebScraper: agentConfig.toolOptions.useWebScraper,
    useDeepSearch: shouldUseDeepSearch
  });
  
  // Configure and create the chat engine
  const engineConfig: ChatEngineConfig = {
    tools,
    requiresAuth: !bypassAuth,
    model: agentConfig.model || 'gpt-4o',
    temperature: agentConfig.temperature || 0.7,
    systemPrompt: prompts.buildSystemPrompt(agentType, shouldUseDeepSearch),
    operationName: `chat_${agentType}`,
    useDeepSearch: shouldUseDeepSearch,
    body: {
      deepSearchEnabled: shouldUseDeepSearch,
      sessionId,
      userId: persistenceUserId,
      agentType,
      maxSteps: 5,
      toolChoice: shouldUseDeepSearch ? 'auto' : 'none'
    }
  };
  
  // Create and use the chat engine
  const engine = new ChatEngine(engineConfig);
  return engine.handleRequest(req);
}
```

### Deep Search Implementation

The Deep Search tool follows a layered architecture:
1. **Tool Definition**: Implements the Vercel AI SDK Tool interface for chat engine integration
2. **Service Layer**: Provides an abstracted Perplexity API client
3. **Security Controls**: Includes multiple validation layers:
   - Conditional tool inclusion based on agent capabilities and user preferences
   - Explicit checks in tool execution to verify authorization
   - Detailed logging for security auditing

```typescript
// Deep Search tool with security controls
export const deepSearchTool = tool({
  description: "Search the web for up-to-date information about any topic...",
  parameters: deepSearchSchema,
  execute: async ({ search_term }, runOptions) => {
    // Extract deepSearchEnabled from the options payload
    const deepSearchEnabled = runOptions.body?.deepSearchEnabled === true;
    
    // CRITICAL SAFETY CHECK: Verify deep search is explicitly enabled
    if (!deepSearchEnabled) {
      edgeLogger.warn("Deep Search tool was invoked without being enabled", {
        // Detailed logging
      });
      
      return "I'm sorry, but web search capabilities are not enabled...";
    }
    
    // Tool implementation with proper error handling
  }
});
```

## Migration Status

### Completed Tasks

1. **Core Engine Creation**
   - ✅ Created `lib/chat-engine/core.ts` with ChatEngine class and factory function
   - ✅ Implemented auth handling, CORS configuration, and error handling
   - ✅ Added comprehensive logging throughout the workflow

2. **Prompt Management**
   - ✅ Created modular prompt system in `lib/chat-engine/prompts/`
   - ✅ Implemented specialized prompts for different agent types
   - ✅ Added tool-specific instructions to prompts

3. **Tool System**
   - ✅ Created standardized tool implementations following AI SDK patterns
   - ✅ Implemented conditional tool inclusion based on configuration
   - ✅ Added proper parameter validation and error handling

4. **Agent Routing**
   - ✅ Implemented AI-powered agent routing using Vercel AI SDK's generateObject
   - ✅ Created agent-specific configurations with appropriate tools
   - ✅ Added fallback mechanisms for routing failures

5. **Cache Service**
   - ✅ Created unified caching service with consistent key management
   - ✅ Implemented specialized methods for different data types
   - ✅ Added proper error handling and logging

6. **Route Handler Refactoring**
   - ✅ Refactored main chat route handler to use the new engine
   - ✅ Refactored widget chat route handler to use the new engine
   - ✅ Added agent-specific configurations

7. **Frontend Component Updates**
   - ✅ Created `useAppChat` hook to wrap Vercel AI SDK's `useChat`
   - ✅ Rebuilt chat widget using Vercel AI SDK patterns
   - ✅ Implemented continuous scrolling and visual improvements
   - ✅ Added cold start optimization and retry mechanisms

### Replaced Files

The following files have been replaced by our new implementation:

- ❌ `lib/chat/tools.ts` → `lib/chat-engine/tools/`
- ❌ `lib/chat/prompt-builder.ts` → `lib/chat-engine/prompts/`
- ❌ `lib/agents/agent-router.ts` → `lib/chat-engine/agent-router.ts`
- ❌ `lib/chat/tool-manager.ts` → `lib/chat-engine/tools/registry.ts`
- ❌ `lib/chat/validator.ts` → Validation in ChatEngine
- ❌ `lib/chat/stream-processor.ts` → Vercel AI SDK's native streaming
- ❌ `lib/chat/cache.service.ts` → `lib/chat-engine/cache-service.ts`
- ❌ `components/chat-widget/chat-widget.tsx` → `chat-widget-v2.tsx`
- ❌ `components/chat-widget/chat-widget-provider.tsx` → Vercel AI SDK state management

### Files Moved

- ✅ `lib/vector/documentRetrieval.ts` → `lib/services/vector/document-retrieval.ts`
- ✅ `lib/vector/embeddings.ts` → `lib/services/vector/embeddings.ts`
- ✅ `lib/vector/types.ts` → `lib/services/vector/types.ts`

## Benefits of the New Architecture

1. **Alignment with Vercel AI SDK**: Follows best practices from the official SDK
2. **Reduced Code Duplication**: Unified implementation for main chat and widget
3. **Enhanced Maintainability**: Clear separation of concerns and modular design
4. **Improved Performance**: Optimized caching and streamlined request handling
5. **Better Security**: Multiple layers of validation for sensitive features
6. **Easier Extension**: Adding new agent types or tools requires minimal changes
7. **Comprehensive Logging**: Detailed logging throughout for debugging and analytics
8. **Graceful Error Handling**: Consistent error handling patterns across components
9. **Cold Start Optimization**: Multi-layered approach to minimize cold start impact

## References

- [Vercel AI SDK Documentation](https://sdk.vercel.ai/docs)
- [OpenAI Function Calling Guide](https://platform.openai.com/docs/guides/function-calling)
- [Zod Schema Validation](https://zod.dev/)
