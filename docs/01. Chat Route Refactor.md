I'll thoroughly analyze the current implementation, verify all existing files, and update the refactoring plan with a more precise approach.

Read file: /Users/Humberto/Documents/GitHub/backups/during lint/san-diego-version/lib/chat-engine/core.ts

Read file: /Users/Humberto/Documents/GitHub/backups/during lint/san-diego-version/lib/chat-engine/agent-router.ts

Read file: /Users/Humberto/Documents/GitHub/backups/during lint/san-diego-version/lib/chat-engine/tools/registry.ts

Read file: /Users/Humberto/Documents/GitHub/backups/during lint/san-diego-version/lib/chat-engine/prompts/index.ts

Read file: /Users/Humberto/Documents/GitHub/backups/during lint/san-diego-version/lib/chat-engine/core.ts

Read file: /Users/Humberto/Documents/GitHub/backups/during lint/san-diego-version/lib/chat-engine/core.ts

Read file: /Users/Humberto/Documents/GitHub/backups/during lint/san-diego-version/app/api/widget-chat/route.ts
Based on my thorough analysis of the existing code and the refactoring plan, here's a comprehensive and precise plan to refactor the main chat route:

# Updated Refactoring Plan for app/api/chat/route.ts

## 1. Current State Analysis

The current `app/api/chat/route.ts` file is approximately 1400 lines and contains complex functionality including:

- User authentication via Supabase
- Deep Search integration with Perplexity API
- Agent routing with keyword-based detection
- Vector search for RAG capabilities
- Web scraping logic
- URL detection and processing
- Message history management
- Redis caching
- Response validation and formatting
- Streaming response handling

Most of this logic has already been extracted into the chat engine, so our refactoring will focus on configuring and delegating to the engine.

## 2. Available Chat Engine Components

The following components have been successfully implemented and tested:

1. **Core Chat Engine**:
   - `createChatEngine` factory function
   - `ChatEngine` class with `handleRequest` method
   - Authentication handling
   - Request parsing
   - Error handling
   - CORS support
   - Timeout management

2. **Agent Router**:
   - `detectAgentType` function using AI to classify messages
   - `createAgentToolSet` function to get appropriate tools
   - Agent configuration with temperature settings
   - Support for all agent types

3. **Tool Registry**:
   - `createToolSet` function for custom tool selection
   - Pre-configured tool sets for different scenarios
   - Knowledge base tool
   - Web scraper tool
   - RAG tool following Vercel AI SDK patterns

4. **Prompts System**:
   - `buildSystemPrompt` function for agent-specific prompts
   - `buildChatEnginePrompt` for all prompt types
   - Support for enhancing prompts with tool results
   - Convenience methods via `prompts` object

## 3. Deep Search Implementation

A key focus of this refactoring is implementing a robust Deep Search feature that only triggers when explicitly enabled by the user. We've implemented a multi-layered approach to control Deep Search availability:

### 3.1 Deep Search Tool Definition

We've created a `deep-search.ts` file in the `lib/chat-engine/tools` directory:

```typescript
/**
 * Deep Search Tool
 * 
 * This module implements a Deep Search tool using the Perplexity API to perform
 * comprehensive web research on complex queries. The tool is designed to only execute
 * when explicitly enabled by the user through the deepSearchEnabled flag.
 */

import { tool, type ToolExecutionOptions } from 'ai';
import { z } from 'zod';
import { edgeLogger } from '@/lib/logger/edge-logger';
import { LOG_CATEGORIES } from '@/lib/logger/constants';
import { callPerplexityAPI } from '@/lib/agents/tools/perplexity/api';

/**
 * Interface for extended tool options with deepSearch flag
 */
interface DeepSearchOptions extends ToolExecutionOptions {
  body?: {
    deepSearchEnabled?: boolean;
    [key: string]: any;
  };
}

/**
 * Deep Search tool implementation following Vercel AI SDK pattern
 * Includes multiple layers of protection:
 * 1. Tool is only included in the tools object when enabled (primary protection)
 * 2. System prompt indicates availability (secondary protection)
 * 3. Execute function verifies flag is enabled (tertiary protection)
 */
export const deepSearchTool = tool({
  description: 'Perform comprehensive web research on a complex topic to find current, in-depth information from the internet',
  parameters: z.object({
    query: z.string().describe('The research query to investigate thoroughly')
  }),
  execute: async ({ query }, options) => {
    // Cast options to our extended type that includes the body property
    const extendedOptions = options as DeepSearchOptions;
    
    // Triple-check: Verify the flag is enabled before executing
    if (!extendedOptions.body?.deepSearchEnabled) {
      edgeLogger.warn('Deep Search tool called but not enabled', {
        category: LOG_CATEGORIES.TOOLS,
        operation: 'deep_search_blocked',
        reason: 'flag_not_enabled',
        query
      });
      return "Deep Search is not enabled for this conversation. Please enable Deep Search to use this feature.";
    }
    
    // Log the search execution
    edgeLogger.info('Running Deep Search', {
      category: LOG_CATEGORIES.TOOLS,
      operation: 'deep_search_start',
      query
    });
    
    // Execute the deep search using the Perplexity API
    try {
      const result = await callPerplexityAPI(query);
      
      // Log successful execution
      edgeLogger.info('Deep Search completed successfully', {
        category: LOG_CATEGORIES.TOOLS,
        operation: 'deep_search_complete',
        queryLength: query.length,
        resultLength: result.content.length
      });
      
      return result.content;
    } catch (error) {
      // Log any errors that occur during execution
      edgeLogger.error('Deep Search execution failed', {
        category: LOG_CATEGORIES.TOOLS,
        operation: 'deep_search_failed',
        query,
        error: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined
      });
      
      return "The Deep Search operation failed. Please try again with a more specific query.";
    }
  }
});
```

### 3.2 Updated Tool Registry

We've updated the Tool Registry to conditionally include the Deep Search tool based on feature flags:

```typescript
// In lib/chat-engine/tools/registry.ts
import { deepSearchTool } from './deep-search';

/**
 * Creates a customized tool set based on feature flags
 */
export function createToolSet(options: {
    useKnowledgeBase?: boolean;
    useWebScraper?: boolean;
    useDeepSearch?: boolean;
    useRagTool?: boolean;
}): Record<string, Tool<any, any>> {
    const {
        useKnowledgeBase = true,
        useWebScraper = false,
        useDeepSearch = false,
        useRagTool = true
    } = options;

    const toolSet: Record<string, Tool<any, any>> = {};

    // Add knowledge base tool if enabled
    if (useKnowledgeBase) {
        toolSet.getInformation = knowledgeBaseTool;
    }

    // Add web scraper tool if enabled
    if (useWebScraper) {
        toolSet.scrapeWebContent = webScraperTool;
    }

    // Add RAG tool if enabled
    if (useRagTool) {
        toolSet.getContext = ragTool;
    }

    // Add Deep Search tool ONLY if explicitly enabled
    if (useDeepSearch) {
        toolSet.deepSearch = deepSearchTool;
    }

    return toolSet;
}
```

### 3.3 Agent Router Integration

Update the Agent Router to provide tool configuration options for each agent type:

```typescript
// In lib/chat-engine/agent-router.ts
export async function detectAgentType(
  message: string, 
  requestedAgentId: AgentType = 'default'
): Promise<{ agentType: AgentType; config: AgentConfig }> {
  // Logic to determine agent type
  // ...
  
  // Return the agent type and its configuration
  return {
    agentType,
    config: {
      temperature: 0.7,
      toolOptions: {
        useKnowledgeBase: true,
        useRagTool: true,
        useWebScraper: agentType === 'copywriting' || agentType === 'google-ads' || agentType === 'facebook-ads',
        useDeepSearch: agentType === 'copywriting' || agentType === 'google-ads' || agentType === 'facebook-ads'
      }
    }
  };
}
```

## 4. Refactoring Implementation

### Step 1: Create a backup file
```bash
cp app/api/chat/route.ts app/api/chat/route.ts.bak
```

### Step 2: Implement the new route handler

```typescript
/**
 * Main Chat API Route
 * 
 * This route handler uses the unified chat engine to process chat requests.
 * It handles agent selection, authentication, and delegates core functionality
 * to the chat engine components.
 */

import { createChatEngine } from '@/lib/chat-engine/core';
import { detectAgentType } from '@/lib/chat-engine/agent-router';
import { createToolSet } from '@/lib/chat-engine/tools/registry';
import { prompts } from '@/lib/chat-engine/prompts';
import { edgeLogger } from '@/lib/logger/edge-logger';
import { validateChatRequest } from '@/lib/chat/validator';

// Maintain existing runtime directives
export const runtime = 'edge';
export const maxDuration = 120;
export const dynamic = 'force-dynamic';

export async function POST(req: Request) {
  const startTime = Date.now();
  
  try {
    // Extract the request body
    const body = await req.json();
    
    // Use the validated chat request which handles both formats
    const { messages: clientMessages, id: sessionId, deepSearchEnabled = false, agentId: requestedAgentId = 'default' } = validateChatRequest(body);
    
    // Basic validation
    if (!clientMessages || !Array.isArray(clientMessages) || clientMessages.length === 0) {
      return new Response(
        JSON.stringify({ error: 'Invalid request: messages required' }), 
        { status: 400, headers: { 'Content-Type': 'application/json' } }
      );
    }
    
    if (!sessionId) {
      return new Response(
        JSON.stringify({ error: 'Invalid request: session ID required' }), 
        { status: 400, headers: { 'Content-Type': 'application/json' } }
      );
    }
    
    // Get the latest user message for agent detection
    const lastUserMessage = clientMessages[clientMessages.length - 1];
    
    edgeLogger.info('Chat request received', {
      operation: 'chat_request',
      sessionId,
      deepSearchEnabled,
      requestedAgentId,
      messageCount: clientMessages.length
    });
    
    // Detect the appropriate agent type based on message content
    const { agentType, config: agentConfig } = await detectAgentType(
      lastUserMessage.content as string,
      requestedAgentId as any
    );
    
    edgeLogger.info('Agent type detected', {
      operation: 'agent_detection',
      sessionId,
      detectedAgent: agentType,
      requestedAgent: requestedAgentId,
      selectionMethod: requestedAgentId === 'default' ? 'automatic' : 'user-selected'
    });
    
    // Determine if this agent type can use Deep Search
    const canAgentUseDeepSearch = agentConfig.toolOptions.useDeepSearch;
    
    // Only enable Deep Search if both the user has toggled it AND the agent supports it
    const shouldUseDeepSearch = canAgentUseDeepSearch && deepSearchEnabled;
    
    // Create tools object with conditional inclusion of Deep Search
    const tools = createToolSet({
      useKnowledgeBase: agentConfig.toolOptions.useKnowledgeBase,
      useWebScraper: agentConfig.toolOptions.useWebScraper,
      useDeepSearch: shouldUseDeepSearch, // Only include if explicitly enabled
      useRagTool: agentConfig.toolOptions.useRagTool
    });
    
    edgeLogger.info('Tool selection', {
      operation: 'tool_selection',
      toolNames: Object.keys(tools),
      deepSearchEnabled,
      shouldUseDeepSearch,
      deepSearchIncluded: 'deepSearch' in tools
    });
    
    // Create the chat engine with the detected agent configuration
    const engine = createChatEngine({
      tools, // Tools object built conditionally
      requiresAuth: true,
      corsEnabled: false,
      systemPrompt: prompts.buildSystemPrompt(agentType, shouldUseDeepSearch), // Pass flag to prompt builder
      maxTokens: 16000,
      temperature: agentConfig.temperature,
      operationName: `chat_${agentType}`,
      cacheEnabled: true,
      messageHistoryLimit: 50,
      // Pass additional configuration for tools
      body: { 
        deepSearchEnabled: shouldUseDeepSearch, // Pass for safety check in execute function
        sessionId,
        agentType
      }
    });
    
    edgeLogger.info('Chat engine created', {
      operation: 'chat_engine_created',
      sessionId,
      agentType,
      deepSearchEnabled: shouldUseDeepSearch,
      toolCount: Object.keys(tools).length,
      elapsedMs: Date.now() - startTime
    });
    
    // Let the engine handle the request
    return engine.handleRequest(req);
    
  } catch (error) {
    // Log the error
    edgeLogger.error('Unhandled error in chat route', {
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined
    });
    
    // Return a user-friendly error response
    return new Response(
      JSON.stringify({ 
        error: 'An error occurred processing your request',
        message: error instanceof Error ? error.message : 'Unknown error'
      }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
}
```

## 5. Testing Plan

### 5.1 Deep Search Specific Tests

1. **Deep Search Toggle Test**:
   - Send identical queries with Deep Search enabled and disabled
   - Verify that Deep Search is only used when enabled
   - Confirm the tool isn't called when disabled
   - Check logs to verify proper functioning

2. **Deep Search Protection Tests**:
   - Attempt to trick the model into using Deep Search when disabled
   - Send prompts that explicitly request using Deep Search without the toggle
   - Verify the tool can't be executed without the flag

3. **Tool Execution Verification**:
   - Check execution logs to verify Deep Search is properly handling the flag
   - Validate the results when Deep Search is properly triggered
   - Test error handling when Deep Search API is unavailable

### 5.2 General Tests

1. **Basic Chat Test**:
   - Send a simple message to verify the response
   - Check that history is saved correctly
   - Verify that streaming works

2. **Agent Detection Test**:
   - Send messages that should trigger different agents
   - Verify that the correct agent is selected
   - Check that specialized prompts are used

3. **Tool Usage Test**:
   - Send queries that should use different tools
   - Verify that the RAG tool retrieves relevant information
   - Check that web scraper works when URLs are present

4. **Error Handling Test**:
   - Simulate authentication failures
   - Test with malformed requests
   - Verify timeout handling works correctly

## 6. Migration Strategy

To ensure a smooth migration with minimal risk:

1. **Deploy as a Separate Route First**:
   - Create a new route at `/api/chat-engine` with the refactored code
   - Test extensively while maintaining the old implementation
   - Gradually shift traffic once confident

2. **A/B Testing**:
   - Implement a toggle to direct a percentage of requests to the new implementation
   - Compare performance, error rates, and user satisfaction

3. **Gradual Rollout**:
   - Start with internal users and beta testers
   - Expand to a small percentage of production users
   - Monitor logs closely for any issues
   - Increase percentage gradually to 100%

## 7. Verification Checklist

Before considering the refactoring complete, verify:

- [ ] All agent types work correctly (default, copywriting, google-ads, facebook-ads, quiz)
- [ ] Deep Search functions when enabled
- [ ] Web scraper retrieves content from URLs
- [ ] Knowledge base provides relevant information
- [ ] Authentication works correctly
- [ ] Error handling is robust
- [ ] Response format matches the original implementation
- [ ] Performance is equal or better than the original
- [ ] Logging provides sufficient detail for debugging
- [ ] All edge cases are handled correctly

## 8. Follow-up Tasks

After the refactoring is complete:

1. **Documentation**:
   - Update the architecture documentation
   - Document the new configuration options
   - Create examples for common use cases

2. **Performance Optimization**:
   - Analyze request timing with the new implementation
   - Identify and address any bottlenecks
   - Fine-tune caching strategies

3. **Feature Enhancements**:
   - Implement any new features that were challenging with the old architecture
   - Consider adding analytics to track tool usage and effectiveness

This comprehensive plan ensures a smooth transition to the new chat engine architecture while maintaining all existing functionality and providing a path for future improvements.
