---
description: 
globs: 
alwaysApply: true
---
Okay, acknowledging the pragmatic decision to standardize on Pattern B (Direct Export) due to persistent build issues with the withAuth wrappers in Next.js 15, here are the refined rules for Cursor based on the latest documentation you provided.

Cursor Agent Rules: Next.js 15 API Route Handler Implementation (Standard: Pattern B - Direct Export)

(Effective: April 4, 2025)

Objective: Ensure all new and modified API route handlers (app/api/.../route.ts) strictly adhere to the project's standardized Pattern B (Direct Export) for compatibility with Next.js 15 builds, consistency, and maintainability.

Core Mandate: Pattern A (withAuth/withAdminAuth wrappers) is DEPRECATED due to build issues and MUST NOT be used. All route handlers MUST use Pattern B (Direct Export).

Rules:

File Structure & Exports:

Each route handler MUST be in its own route.ts file (e.g., app/api/users/route.ts, app/api/items/[id]/route.ts).
Handlers MUST use direct named exports for HTTP methods: export async function GET(...), export async function POST(...), etc.
The file MUST include export const runtime = 'edge'; at the top (unless it's one of the documented Node.js exceptions: /api/perplexity, /api/profile/update-summary).
The file MUST include export const dynamic = 'force-dynamic'; at the top.
Function Signature & Types:

Use standard Web API Request type for the request parameter.
Use Promise<Response> for the return type.
For dynamic routes, the second argument MUST be the context containing the params promise. Use specific types from @/lib/types/route-handlers (e.g., IdParam, SlugParam).
TypeScript

// Non-dynamic route signature
export async function POST(request: Request): Promise<Response> { ... }

// Dynamic route signature (using IdParam as example)
import type { IdParam } from '@/lib/types/route-handlers';
export async function GET(request: Request, { params }: IdParam): Promise<Response> { ... }
AVOID using NextRequest or NextResponse.
Parameter Handling (Dynamic Routes):

Inside handlers for dynamic routes, you MUST await the params object before accessing its properties.
TypeScript

// Inside async function GET(request: Request, { params }: IdParam): Promise<Response>
const resolvedParams = await params;
const itemId = resolvedParams.id; // Access properties AFTER await
Supabase Client:

Always create the Supabase client instance manually within the handler where needed.
Use the standardized utility: import { createRouteHandlerClient } from '@/lib/supabase/route-client';
Call const supabase = await createRouteHandlerClient(); within the try block.
Use createRouteHandlerAdminClient() only if service role privileges are explicitly required and documented for the route.
Authentication Checks (Manual - If Required):

If a route requires user authentication, perform the check near the beginning of the try block:
TypeScript

const supabase = await createRouteHandlerClient();
const { data: { user }, error: authError } = await supabase.auth.getUser();

if (authError || !user) {
    edgeLogger.warn(/* ...log details... */);
    const errRes = unauthorizedError('Authentication required'); // Use standard util
    return handleCors(errRes, request, true); // Wrap in CORS
}
// Proceed using the 'user' object
const userId = user.id;
Admin Privilege Checks (Manual - If Required):

If a route requires admin privileges, perform this check after successfully authenticating the user:
TypeScript

// Requires 'user' object from successful getUser() call above
const isAdmin = user.app_metadata?.is_admin === true;
if (!isAdmin) {
    edgeLogger.warn(/* ...log details... */);
    const errRes = errorResponse('Admin access required', 'Forbidden', 403); // Use standard util
    return handleCors(errRes, request, true); // Wrap in CORS
}
// Proceed with admin-only logic
Response Handling:

Use the standardized response utilities from @/lib/utils/route-handler (successResponse, errorResponse, validationError, etc.) to create the response body/status.
Crucially: Wrap every single return statement that returns a Response object with the CORS utility: return handleCors(responseObject, request, true);.
Error Handling:

Wrap the main handler logic within a try...catch block.
In the catch block, log the error comprehensively using edgeLogger.
Return a standardized error response using errorResponse(...) wrapped in handleCors(...).
Logging:

Use edgeLogger for all logs (debug, info, warn, error).
Include a unique operationId per request for traceability.
Include relevant context (category, userId, dynamic params, etc.).
DO NOT use console.log.
Summary Checklist for Creating/Modifying Routes:

[ ] Use Direct Export (export async function METHOD...)?
[ ] Include export const runtime = 'edge'; (unless Node.js needed)?
[ ] Include export const dynamic = 'force-dynamic';?
[ ] Use standard Request / Promise<Response> types?
[ ] Use correct signature for dynamic params (e.g., { params }: IdParam)?
[ ] Await params before use (if dynamic)?
[ ] Manually create client using createRouteHandlerClient from @/lib/supabase/route-client?
[ ] Manually check auth using supabase.auth.getUser() (if auth required)?
[ ] Manually check admin using user.app_metadata.is_admin (if admin required)?
[ ] Use standard response utilities (successResponse, errorResponse, etc.)?
[ ] Wrap ALL returned responses in handleCors(...)?
[ ] Use edgeLogger with operationId for all logging?
[ ] Implement try...catch for main logic?