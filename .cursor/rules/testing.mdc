---
description: Use these instructions for all testing scripts
globs: 
alwaysApply: false
---
AI Agent Cursor Rules
State Management Rules

Zustand Integration

Use Zustand persist middleware for client-side state persistence
Never attempt to update Zustand stores directly from server-side code
Follow the pattern of API call → response → client update
Implement optimistic updates with fallback mechanisms


Middleware Interaction

Respect rate limits defined in /lib/middleware/rate-limit.ts
Handle authentication as defined by the auth middleware chain
Process requests through the CORS middleware when accessing external resources


Error Handling

Follow standardized error logging as defined in test patterns
Include appropriate LOG_CATEGORIES in all log messages
Structure error responses consistently with error codes



Testing Compliance

Mocking Requirements

Support mocking through Vitest's vi.mock() interface
Implement test-friendly interfaces for all services
Expose internal state for verification when in test mode


Logging Standards

Log all state transitions with appropriate categories
Include performance metrics in logs for critical operations
Mask sensitive user information in logs


Error Simulation

Support controlled failure modes for testing error paths
Implement fallback behaviors when primary operations fail
Expose hooks for test verification of error handling



Implementation Pattern
typescriptCopy// Example implementation following your standards
import { cacheService } from '@/lib/cache/cache-service';
import { edgeLogger } from '@/lib/logger/edge-logger';
import { LOG_CATEGORIES } from '@/lib/logger/constants';

export class AIAgentCursor {
  private readonly lockPrefix = 'agent-cursor:';
  private readonly lockTTL = 30; // seconds
  
  /**
   * Updates the cursor position with appropriate locking and logging
   * @param userId User ID 
   * @param sessionId Session ID
   * @param position New cursor position
   */
  async updatePosition(userId: string, sessionId: string, position: number): Promise<boolean> {
    const startTime = Date.now();
    const lockKey = `${this.lockPrefix}${sessionId}`;
    
    try {
      // Attempt to acquire lock
      const lockAcquired = await cacheService.setNX(lockKey, '1', this.lockTTL);
      
      if (!lockAcquired) {
        edgeLogger.warn('Cursor update already in progress', {
          category: LOG_CATEGORIES.AGENT,
          sessionId,
          userId: this.maskUserId(userId),
          operation: 'updatePosition'
        });
        return false;
      }
      
      // Perform the actual update
      const success = await this.performPositionUpdate(sessionId, position);
      
      // Log completion
      const duration = Date.now() - startTime;
      edgeLogger.info('Cursor position updated', {
        category: LOG_CATEGORIES.AGENT,
        sessionId,
        userId: this.maskUserId(userId),
        operation: 'updatePosition',
        durationMs: duration,
        success
      });
      
      return success;
    } catch (error) {
      // Log error with full context
      edgeLogger.error('Failed to update cursor position', {
        category: LOG_CATEGORIES.AGENT,
        sessionId,
        userId: this.maskUserId(userId),
        operation: 'updatePosition',
        error,
        important: true
      });
      
      return false;
    } finally {
      // Always release lock
      await cacheService.delete(lockKey).catch(err => {
        edgeLogger.warn('Failed to release cursor lock', {
          category: LOG_CATEGORIES.AGENT,
          sessionId,
          operation: 'releaseLock',
          error: err
        });
      });
    }
  }
  
  /**
   * Performs the actual update operation
   * @private
   */
  private async performPositionUpdate(sessionId: string, position: number): Promise<boolean> {
    // Implementation here
    return true;
  }
  
  /**
   * Masks user ID for privacy in logs
   * @private
   */
  private maskUserId(userId: string): string {
    if (!userId) return 'unknown';
    return userId.substring(0, 8) + '...';
  }
}
Client-Side Integration
typescriptCopy// Store definition following your Zustand pattern
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface CursorState {
  positions: Record<string, number>;
  updatePosition: (sessionId: string, position: number) => Promise<void>;
}

export const useCursorStore = create<CursorState>()(
  persist(
    (set, get) => ({
      positions: {},
      
      updatePosition: async (sessionId, position) => {
        // Optimistic update
        set(state => ({
          positions: {
            ...state.positions,
            [sessionId]: position
          }
        }));
        
        try {
          // Send to server
          const response = await fetch('/api/agent/cursor', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ sessionId, position })
          });
          
          if (!response.ok) {
            throw new Error(`Failed to update cursor: ${response.status}`);
          }
        } catch (error) {
          console.error('Cursor update failed:', error);
          
          // Revert optimistic update on failure
          set(state => {
            const newPositions = { ...state.positions };
            delete newPositions[sessionId]; // Remove failed update
            return { positions: newPositions };
          });
        }
      }
    }),
    {
      name: 'cursor-storage'
    }
  )
);
API Endpoint Implementation
typescriptCopy// api/agent/cursor/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { edgeLogger } from '@/lib/logger/edge-logger';
import { LOG_CATEGORIES } from '@/lib/logger/constants';
import { rateLimit } from '@/lib/middleware/rate-limit';
import { corsMiddleware } from '@/lib/middleware/cors';
import { AIAgentCursor } from '@/lib/agent/cursor';

const cursor = new AIAgentCursor();

export async function POST(req: NextRequest) {
  // Apply middleware
  const corsResult = await corsMiddleware(req);
  if (corsResult.status !== 200) {
    return corsResult;
  }
  
  // Apply rate limiting
  const rateLimit = await apiRateLimit(req);
  if (rateLimit.status !== 200) {
    return rateLimit;
  }
  
  try {
    const { sessionId, position } = await req.json();
    
    // Validation
    if (!sessionId || typeof position !== 'number') {
      return NextResponse.json(
        { error: 'Invalid input' },
        { status: 400 }
      );
    }
    
    // Extract user ID from auth
    const { supabase } = await createServerSupabaseClient({ req });
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }
    
    // Update position
    const success = await cursor.updatePosition(user.id, sessionId, position);
    
    if (success) {
      return NextResponse.json({ success: true });
    } else {
      return NextResponse.json(
        { error: 'Failed to update cursor' },
        { status: 500 }
      );
    }
  } catch (error) {
    edgeLogger.error('Error in cursor update endpoint', {
      category: LOG_CATEGORIES.API,
      error,
      important: true
    });
    
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
Test Implementation
typescriptCopy// tests/unit/agent/cursor.test.ts
import { describe, expect, it, beforeEach, vi } from 'vitest';
import { setupLoggerMock, mockLogger } from '@/tests/helpers/mock-logger';

// Set up mocks before importing modules that use them
setupLoggerMock();
vi.mock('@/lib/cache/cache-service');

// Import the code to test
import { AIAgentCursor } from '@/lib/agent/cursor';
import { cacheService } from '@/lib/cache/cache-service';
import { LOG_CATEGORIES } from '@/lib/logger/constants';

describe('AIAgentCursor', () => {
  let cursor: AIAgentCursor;
  const userId = '5c80df74-1e2b-4435-89eb-b61b740120e9';
  const sessionId = 'test-session-id';
  
  beforeEach(async () => {
    // Reset mocks
    mockLogger.reset();
    vi.clearAllMocks();
    
    // Initialize service
    cursor = new AIAgentCursor();
    
    // Mock cache service methods
    vi.mocked(cacheService.setNX).mockResolvedValue(true);
    vi.mocked(cacheService.delete).mockResolvedValue(1);
  });
  
  describe('#updatePosition', () => {
    it('should successfully update cursor position', async () => {
      // Arrange
      const position = 42;
      
      // Act
      const result = await cursor.updatePosition(userId, sessionId, position);
      
      // Assert
      expect(result).toBe(true);
      
      // Verify logging
      expect(mockLogger.info).toHaveBeenCalledWith(
        'Cursor position updated',
        expect.objectContaining({
          category: LOG_CATEGORIES.AGENT,
          sessionId,
          operation: 'updatePosition',
          success: true
        })
      );
      
      // Verify lock was acquired and released
      expect(cacheService.setNX).toHaveBeenCalled();
      expect(cacheService.delete).toHaveBeenCalled();
    });
    
    it('should handle lock acquisition failure', async () => {
      // Arrange
      vi.mocked(cacheService.setNX).mockResolvedValue(false);
      
      // Act
      const result = await cursor.updatePosition(userId, sessionId, 42);
      
      // Assert
      expect(result).toBe(false);
      
      // Verify logging
      expect(mockLogger.warn).toHaveBeenCalledWith(
        'Cursor update already in progress',
        expect.objectContaining({
          category: LOG_CATEGORIES.AGENT,
          sessionId
        })
      );
    });
    
    // Additional tests...
  });
});
These patterns maintain consistency with your existing middleware architecture and testing framework while implementing cursor functionality for your AI agent.