---
description: 
globs: 
alwaysApply: true
---
# CursorMD Agent Testing Guidelines

This document outlines the standard testing approach for CursorMD agents based on our Vitest framework.

## Core Testing Principles

1. **Test in Isolation**: Each agent function must be tested independently without side effects
2. **Mock External Dependencies**: Never allow agents to make real API calls during tests
3. **Verify Logging**: Confirm agents log appropriate messages using the mock logger
4. **Test Edge Cases**: Validate agent behavior with invalid inputs, timeouts, and failure scenarios

## Directory Structure

Add agent tests in the appropriate locations:

```
tests/
├── unit/
│   ├── agents/                      # Unit tests for agent components
│   │   ├── title-agent.test.ts      # Tests for title generation agent
│   │   ├── search-agent.test.ts     # Tests for search functionality
│   │   └── ...
│   └── chat-engine/
│       ├── agent-manager.test.ts    # Tests for agent orchestration logic
│       └── ...
├── integration/
│   └── agents/                      # Tests for multi-agent interactions
└── helpers/
    ├── mock-agents.ts              # Mock implementations of agents
    └── test-data/
        └── agent-test-data.ts      # Sample data for agent testing
```

## Mock Setup Requirements

All agent tests must use the following mock setup pattern:

```typescript
import { describe, expect, it, beforeEach, vi } from 'vitest';
import { setupLoggerMock, mockLogger } from '@/tests/helpers/mock-logger';

// Set up mocks BEFORE importing agent modules
setupLoggerMock();

// Import the agent to test
import { TitleAgent } from '@/lib/agents/title-agent';

describe('TitleAgent', () => {
  let titleAgent;
  
  beforeEach(() => {
    // Reset all mocks
    mockLogger.reset();
    vi.clearAllMocks();
    
    // Initialize the agent with test configuration
    titleAgent = new TitleAgent();
  });
  
  // Tests...
});
```

## AI Model Testing

For agents that use AI models:

1. **Mock AI Responses**: Create consistent, predefined responses for AI models
2. **Test Response Parsing**: Verify correct handling of model outputs
3. **Validate Prompt Construction**: Ensure effective prompt creation
4. **Test Rate Limiting**: Verify rate limit handling in agents

Example AI model mocking:

```typescript
// Mock OpenAI for title generation
vi.mock('openai', () => {
  return {
    OpenAI: vi.fn().mockImplementation(() => ({
      chat: {
        completions: {
          create: vi.fn().mockResolvedValue({
            choices: [{
              message: {
                content: 'Generated Title Example'
              }
            }],
            usage: {
              prompt_tokens: 50,
              completion_tokens: 10
            }
          })
        }
      }
    }))
  };
});
```

## Testing Agent Functions

Each agent should be tested for:

### 1. Core Functionality

```typescript
it('should generate a title from user message', async () => {
  // Arrange
  const chatId = 'test-chat-id';
  const userMessage = 'How do I improve my JavaScript skills?';
  
  // Act
  const result = await titleAgent.generateTitle(chatId, userMessage);
  
  // Assert
  expect(result).toBe('Generated Title Example');
  expect(mockLogger.info).toHaveBeenCalledWith(
    expect.stringContaining('Title generated'),
    expect.objectContaining({
      category: LOG_CATEGORIES.AGENT,
      chatId
    })
  );
});
```

### 2. Error Handling

```typescript
it('should handle API errors gracefully', async () => {
  // Arrange
  const chatId = 'test-chat-id';
  const userMessage = 'Test message';
  
  // Mock API failure
  const openaiMock = await import('openai');
  openaiMock.OpenAI.mockImplementationOnce(() => ({
    chat: {
      completions: {
        create: vi.fn().mockRejectedValue(new Error('API Error'))
      }
    }
  }));
  
  // Act
  const result = await titleAgent.generateTitle(chatId, userMessage);
  
  // Assert
  expect(result).toBe('Chat About JavaScript'); // Default title
  expect(mockLogger.error).toHaveBeenCalledWith(
    expect.stringContaining('Title generation failed'),
    expect.objectContaining({
      category: LOG_CATEGORIES.AGENT,
      chatId,
      error: expect.any(String)
    })
  );
});
```

### 3. Cache and Database Interactions

```typescript
it('should check for existing title before generation', async () => {
  // Arrange
  const chatId = 'test-chat-id';
  const userMessage = 'Test message';
  
  // Mock database check
  const mockSupabase = {
    from: vi.fn().mockReturnThis(),
    select: vi.fn().mockReturnThis(),
    eq: vi.fn().mockReturnThis(),
    single: vi.fn().mockResolvedValue({
      data: { title: 'Existing Title' }
    })
  };
  
  vi.spyOn(titleAgent, 'getDatabaseClient').mockReturnValue(mockSupabase);
  
  // Act
  const result = await titleAgent.generateTitle(chatId, userMessage);
  
  // Assert
  expect(result).toBeNull(); // No new title generated
  expect(mockLogger.info).toHaveBeenCalledWith(
    expect.stringContaining('Title already exists'),
    expect.objectContaining({
      category: LOG_CATEGORIES.AGENT,
      chatId
    })
  );
});
```

## Integration Testing for Multi-Agent Scenarios

```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { setupLoggerMock, mockLogger } from '@/tests/helpers/mock-logger';

setupLoggerMock();

import { AgentManager } from '@/lib/chat-engine/agent-manager';
import { TitleAgent } from '@/lib/agents/title-agent';
import { SearchAgent } from '@/lib/agents/search-agent';

describe('Agent Collaboration', () => {
  let agentManager, titleAgent, searchAgent;
  
  beforeEach(() => {
    mockLogger.reset();
    
    titleAgent = new TitleAgent();
    searchAgent = new SearchAgent();
    
    // Mock agent methods
    vi.spyOn(titleAgent, 'generateTitle').mockResolvedValue('Research Results');
    vi.spyOn(searchAgent, 'performSearch').mockResolvedValue(['result1', 'result2']);
    
    agentManager = new AgentManager(titleAgent, searchAgent);
  });
  
  it('should coordinate search and title generation', async () => {
    // Arrange
    const chatId = 'test-chat-id';
    const query = 'quantum computing';
    
    // Act
    const result = await agentManager.processQuery(chatId, query);
    
    // Assert
    expect(searchAgent.performSearch).toHaveBeenCalledWith(query);
    expect(titleAgent.generateTitle).toHaveBeenCalledWith(
      chatId, 
      expect.stringContaining(query)
    );
    expect(result.title).toBe('Research Results');
    expect(result.searchResults).toEqual(['result1', 'result2']);
  });
});
```

## Rate Limiting and Concurrency Tests

```typescript
it('should respect rate limits', async () => {
  // Arrange
  const chatId = 'test-chat-id';
  const userMessage = 'Test message';
  
  // Create a spy on the rate limiter
  const rateLimiterSpy = vi.spyOn(titleAgent.rateLimiter, 'check')
    .mockResolvedValue(false); // Simulate rate limit reached
  
  // Act
  const result = await titleAgent.generateTitle(chatId, userMessage);
  
  // Assert
  expect(result).toBe('Rate Limited Chat'); // Default rate-limited title
  expect(mockLogger.warn).toHaveBeenCalledWith(
    expect.stringContaining('Rate limit reached'),
    expect.objectContaining({
      category: LOG_CATEGORIES.AGENT,
      chatId
    })
  );
});
```

## Testing Agent Timeouts

```typescript
it('should handle timeouts gracefully', async () => {
  // Arrange
  const chatId = 'test-chat-id';
  const userMessage = 'Test message';
  
  // Mock OpenAI to never resolve
  const openaiMock = await import('openai');
  openaiMock.OpenAI.mockImplementationOnce(() => ({
    chat: {
      completions: {
        create: vi.fn().mockImplementation(() => new Promise(resolve => {
          // This promise will never resolve within the test timeout
          setTimeout(resolve, 30000);
        }))
      }
    }
  }));
  
  // Set a short timeout for the agent
  titleAgent.requestTimeout = 100; // ms
  
  // Act
  const result = await titleAgent.generateTitle(chatId, userMessage);
  
  // Assert
  expect(result).toBe('Timed Out Chat'); // Default timeout title
  expect(mockLogger.warn).toHaveBeenCalledWith(
    expect.stringContaining('Request timed out'),
    expect.objectContaining({
      category: LOG_CATEGORIES.AGENT,
      chatId,
      timeoutMs: 100
    })
  );
});
```

## Performance Testing Guidelines

For agent performance testing:

1. **Measure Execution Time**: Track response times for different inputs
2. **Test Concurrent Requests**: Verify behavior under load
3. **Memory Usage**: Monitor agent memory footprint during operations

```typescript
it('should complete title generation within acceptable time', async () => {
  // Arrange
  const chatId = 'test-chat-id';
  const userMessage = 'Test message';
  
  // Act
  const startTime = performance.now();
  await titleAgent.generateTitle(chatId, userMessage);
  const endTime = performance.now();
  const executionTime = endTime - startTime;
  
  // Assert
  expect(executionTime).toBeLessThan(200); // Should complete within 200ms
});
```

## Best Practices

1. **Deterministic Tests**: Ensure tests produce the same results on each run
2. **Explicit Test Data**: Use clear, purpose-built test data from test-data files
3. **Avoid Conditional Tests**: Tests should never depend on environment conditions
4. **Clear Assertions**: Each test should have explicit assertions that verify specific outcomes
5. **Test Both Success and Failure**: Verify both happy path and error scenarios
6. **Descriptive Test Names**: Test names should clearly describe the behavior being tested

Follow this guidance for all agent testing to ensure reliability and maintainability.